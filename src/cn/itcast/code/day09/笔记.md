#### final关键字
    常见的时它可以修饰类，方法，变量
        特点：
        final修饰类,该类不能被继承
        final修饰方法，该方法不能被重写（覆盖，重写）
        final修饰变量,该变量不能被重新赋值，因为这个变量其实时常量
        
    常量：
        A:字面值常量  “hello” 10 ,true
        B:自定义常量   final int x = 10
        
    final关键字修饰局部变量
    	基本类型：基本类型的值不能发生改变
    	引用类型：引用类型的地址值不能发生改变，但是，该对象的堆内存的值时可以改变的
    final修饰变量的初始化时机
    	A:被final修饰的变量只能赋值一次
    	B:在构造方法完毕前修饰变量（非静态的常量）

#### 多态
    某一事物没在不同时刻表现出来的不同状态
	举例：
	    猫是猫 猫是动物
	    水（固态 液态 气态）
	多态的前提：
	    A:要有继承关系
	    B:要有方法重写
	    C:要有父类引用指向子类对象。
	        父 f = new 子();
	多态中成员访问特点：
	    A:成员变量
	        编译看左边，访问看左边
	    B:构造方法
	        创建子类对象的时候，访问父类的构造方法，对父类的数据进行初始化
	    C:成员方法
	        编译看左边，运行看右边
	    D:静态方法
	      编译看左边，访问看左边（静态和类相关，算不上重写，所以，访问还是左边的）
	    
	    由于成员方法存在方法重写，所以它运行是看右边 
#### 多态的好处
        A:提高了代码的维护性（继承保证）
        B:提高了代码的扩展性 （多态保证）
#### 多态的弊端
        A: 不能使用子类的特有功能
        就想使用子类特有功能，怎么办
            A:创建子类对象（多个对象占用内存）
            B:把父类的引用强制转化为子类的引用（向下转型）
            
        
        
#### 多态的向上和向下转型
     对象间的转型问题：
                向上转型： Fu f = new Zi();
                向下转型： Zi z = (Zi) f;
                ClassCastException：一般在多态中的向下转型中出现       	    
	        
#### 抽象类的特点
    A: 抽象类和抽象方法必须用abstract关键字修饰
    B:抽象类不一定有抽象方法，但是有抽象方法的类必须定义为抽象类
    C:抽象类不能实例化，因为它不是具体的,抽象类有构造方法，但是不能实例化，
        构造方法的作用是什么呢？用于子类访问父类数据的初始化
    D:抽象的子类
        a:如果不想重写抽象方法，该子类是一个抽象类
        b:重写所有的抽象方法，这个时候的子类是一个具体的类
    E:抽象类的实例化其实是靠具体的子类实现的，是多态的方式
        Animal2 a = new Dog2();
        
#### 抽象类的成员特点
    A:成员变量：既可以是变量，也可以是常量
    B:构造方法：有，用于子类访问父类数据的初始化
    C:成员方法：  既可以是抽象的，也可以是非抽象的
    
    抽象类的成员方法特性：
    A:抽象方法 强制要求子类做的事情
    B:非抽象方法，子类继承的事情，提高代码复用性 
    
#### 抽象类的问题
    A:一个类如果没有抽象方法，可不可以定义为抽象类?如果可以，有什么意义?
        A:可以。
        B:不让创建对象。
    abstract不能和哪些关键字共存?
     	private	冲突
     	final	冲突	
     	static	无意义
     	    
    
#### 接口的特点 
     A:接口用关键字interface表示
        interface 接口名 {}   
     B:类实现接口用implements表示
        class 类名  implements 接口名 {}
     C:接口不能实例化
        多态实现实例化
     D:接口的子类
            可以是抽象类，但是意义不大
            可以是具体类，重写接口中的所有抽象方法（推荐方案）
        
     具体类多态
     抽象类多态
     接口多态
#### 接口的成员特点
    A:成员变量-只能是常量，并且是静态的 默认修饰符 public static final
    B:构造方法-接口没有构造方法
    C:成员方法-只能是抽象方法，默认修饰符是public abstract
     
     
     所有的类继承自一个类objects
 
### 类与类、类与接口、接口与接口的关系
    类与类：
        继承关系,只能单继承,可以多层继承。
    类与接口：
        实现关系,可以单实现,也可以多实现。
        并且还可以在继承一个类的同时实现多个接口。
    接口与接口：
        继承关系,可以单继承,也可以多继承。
### 抽象类和接口的区别
    A:成员区别
    	抽象类：
    		成员变量：可以变量，也可以常量
    		构造方法：有
    		成员方法：可以抽象，也可以非抽象
    	接口：
    		成员变量：只可以常量
    		成员方法：只可以抽象
    		
    B:关系区别
    	类与类
    		继承，单继承
    	类与接口
    		实现，单实现，多实现
    	接口与接口
    		继承，单继承，多继承
    		
    C:设计理念区别
    	抽象类 被继承体现的是：”is a”的关系。抽象类中定义的是该继承体系的共性功能。
    	接口 被实现体现的是：”like a”的关系。接口中定义的是该继承体系的扩展功能。
    ​			

​	

